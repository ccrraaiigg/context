'From Squeak4.2 of 4 February 2011 [latest update: #10966] on 2 November 2013 at 3:36:36 pm'!Object	subclass: #Other	instanceVariableNames: 'remoteIdentity session '	classVariableNames: 'ReflectiveBehavior '	poolDictionaries: 'ProxyTagConstants '	category: 'System-Spoon'!!Other methodsFor: 'as yet unclassified' stamp: 'crl 7/24/2005 18:22'!counterpart	^OutgoingMessageExchange		counterpartFor: remoteIdentity		over: session! !!Other methodsFor: 'as yet unclassified' stamp: 'crl 6/25/2011 01:21'!forward: aMessage	"Forward aMessage to the remote object I represent, and answer the result."	"This message was invoked by the virtual machine, in response to an attempt to send aMessage to me."	"Transcript cr; print: aMessage; endEntry."	^(		ReflectiveBehavior			at: aMessage selector			ifAbsent: [				^OutgoingMessageExchange					forward: aMessage					for: remoteIdentity					over: session]	)		value: session		value: aMessage arguments! !!Other methodsFor: 'as yet unclassified' stamp: 'il prior: 35745394!!!!!!!!!!!!!!!!'!recyclingHash	"Answer a hash for the purpose of deciding whether or not I should be recycled."	^remoteIdentity + session hash! !!Other methodsFor: 'as yet unclassified'!remoteIdentity: aSmallInteger session: aRemoteMessagingSession 	remoteIdentity _ aSmallInteger.	session _ aRemoteMessagingSession! !!Other methodsFor: 'as yet unclassified' stamp: 'crl 7/14/2011 00:20'!storeOnProxyStream: aStream for: aMessagingSession	(aMessagingSession == session)		ifTrue: [aStream nextWordPut: remoteIdentity]		ifFalse: [			aMessagingSession store: (				OtherMarker new exposureHash: (					aMessagingSession						expose: self						as: self recyclingHash))]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Other class	instanceVariableNames: ''!!Other class methodsFor: 'as yet unclassified' stamp: 'crl 3/29/2008 17:57'!initialize	ReflectiveBehavior _ (		(IdentityDictionary new)			at: #peerAddress			put: [:session :parameters | session peerAddress];			at: #proxyFor:			put: [:session :parameters | parameters only otherVia: session];			yourself).	Smalltalk addToStartUpList: self! !!Other class methodsFor: 'as yet unclassified' stamp: 'crl 9/28/2005 17:46'!readFromProxyStream: aNetStream for: session	^self		withRemoteIdentity: aNetStream nextWord - otherMarkerTagBase		andSession: session! !!Other class methodsFor: 'as yet unclassified' stamp: 'crl 7/30/2006 17:41'!reset	| proxy thisProxy |	proxy _ Other someInstance.	[proxy isNil] whileFalse: [		thisProxy _ proxy.		proxy _ proxy nextInstance.		(Array with: thisProxy) elementsExchangeIdentityWith: (Array with: (Array with: thisProxy recyclingHash))].	Interpreter garbageCollect! !!Other class methodsFor: 'as yet unclassified' stamp: 'crl 10/1/2006 16:21'!resume	self reset! !!Other class methodsFor: 'as yet unclassified' stamp: 'crl 9/27/2005 16:41'!startUp: resuming	resuming ifTrue: [self reset]! !!Other class methodsFor: 'as yet unclassified' stamp: 'il prior: 35751332!!!!!!!!!!!!!!!!'!withRemoteIdentity: aSmallInteger andSession: aRemoteMessagingSession	"Answer a new instance of myself which which corresponds to the remote object with identity aSmallInteger, reachable via aRemoteMessagingSession's network connections."	| recyclingHashValue |	recyclingHashValue _ aSmallInteger + aRemoteMessagingSession hash.	^self		firstInstanceSuchThat: [:other | other recyclingHash = recyclingHashValue]		ifNone: [			(self new)				remoteIdentity: aSmallInteger				session: aRemoteMessagingSession]! !Other initialize!InterpreterPlugin subclass: #Flow	instanceVariableNames: 'hostnameBytes nextSocketKey resourceProxies idleDelay'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Spoon-Virtual Machine Support'!!Flow commentStamp: '<historical>' prior: 0!'	An instance of me can simulate the operation of the Flow plugin, by taking advantage of its runtime behavior. Currently, I cannot generate the Flow plugin itself; it's still built from hand-written C.	Author: Craig Latta <craig@netjam.org>!SharedPool subclass: #VMObjectIndices	instanceVariableNames: ''	classVariableNames: 'ActiveProcessIndex CharacterTable ClassAlien ClassArray ClassBitmap ClassBlockClosure ClassBlockContext ClassByteArray ClassCharacter ClassCompiledMethod ClassExternalAddress ClassExternalData ClassExternalFunction ClassExternalLibrary ClassExternalStructure ClassFloat ClassInteger ClassLargeNegativeInteger ClassLargePositiveInteger ClassMessage ClassMethodContext ClassPoint ClassProcess ClassProxy ClassSemaphore ClassString ClassUnsafeAlien ClassWeakFinalizer CompactClasses ConstMinusOne ConstOne ConstTwo ConstZero ExcessSignalsIndex ExternalObjectsArray FalseObject HeaderIndex InstructionPointerIndex LiteralStart MyListIndex NilObject PrimErrTableIndex PriorityIndex ProcessListsIndex ProcessSignalingLowSpace SchedulerAssociation SelectorAboutToReturn SelectorAttemptToAssign SelectorCannotInterpret SelectorCannotReturn SelectorCounterpart SelectorDoesNotUnderstand SelectorForward SelectorInitProxy SelectorIsNil SelectorMustBeBoolean SelectorNextInstance SelectorProxyHash SelectorRunWithIn SelectorStartReportingSends SelectorStopReportingSends SelectorStoreOnProxyStream SelectorUnreportedSignal SelectorUnreportedWait SenderIndex SpecialSelectors TheDisplay TheFinalizationSemaphore TheInputSemaphore TheInterruptSemaphore TheLowSpaceSemaphore TheTimerSemaphore TrueObject XIndex YIndex'	poolDictionaries: ''	category: 'VMMaker-Interpreter'!!Flow methodsFor: 'socket address resolution' stamp: 'crl 4/25/2004 00:17'!enableResolver	"Enable the resolver corresponding to the supplied handle."	"For simulation, do nothing, since we'll be using a resolver in the simulating system."	interpreterProxy pop: 1! !!Flow methodsFor: 'socket address resolution' stamp: 'crl 4/25/2004 00:14'!newResolverHandleInto	"Write a new resolver handle into a supplied ByteArray."	"For simulation, do nothing, since we'll be using a resolver in the simulating system."	interpreterProxy pop: 1! !!Flow methodsFor: 'socket address resolution' stamp: 'crl 7/6/2005 16:02'!notifyAfterResolvingHostNamed	"Notify the resolver corresponding to a handle, after resolving the number of a hostname."	"For simulation, do nothing, since we'll be using a resolver in the simulating system."	"Remember the hostname the resolver is trying to resolve."	hostnameBytes := (		(			SocketAddressResolver				addressForPort: 0				atHostNamed: (interpreterProxy stringOf: (interpreterProxy stackObjectValue: 0))		)			bytes).	"Signal the resolver's semaphore."	interpreterProxy synchronousSignal: (		interpreterProxy			fetchPointer: 1			ofObject: (interpreterProxy stackObjectValue: 2)).	interpreterProxy pop: 2! !!Flow methodsFor: 'socket address resolution' stamp: 'crl 4/25/2004 00:19'!registerThatResolverHasResolutionIndex	"Register that the socket address resolver corresponding to a handle has a given external semaphore index."	"For simulation, do nothing, since we'll be using a resolver in the simulating system."	interpreterProxy pop: 2! !!Flow methodsFor: 'socket address resolution' stamp: 'crl 7/5/2005 23:09'!writeAddressBytesForResolverInto	"Write IP address bytes, for the hostname that resolver is trying to resolve, into the only parameter (a ByteArray)."	"Assume that the resolver making this request is the same one that made the most recent resolution request (I recorded the corresponding IP address bytes)."	| bytes |	bytes := (interpreterProxy stackObjectValue: 0) + 3.	1		to: 4		do: [:index |			interpreterProxy				byteAt: bytes + index				put: (hostnameBytes at: index)].	interpreterProxy pop: 1! !!Flow methodsFor: 'waiting' stamp: 'crl 4/15/2007 19:43'!notifySocketWhenItMayPerformTimeoutAfter	"Arrange for the socket corresponding to the first parameter (a 'handle') to be notified when it may perform the action corresponding to the second parameter (an 'opcode'), with a timeout in milliseconds corresponding to the third parameter (a SmallInteger)."	| handle resource |	handle := interpreterProxy signed32BitValueOf: (interpreterProxy stackValue: 2).	resource := (resourceProxies at: handle) resource.		resource		notify: resource handle		whenItMayPerform: (interpreterProxy stackIntegerValue: 1)		timeoutAfter: (			((interpreterProxy stackValue: 0) == interpreterProxy nilObject)				ifTrue: [nil]				ifFalse: [interpreterProxy stackIntegerValue: 0]).	interpreterProxy pop: 3! !!Flow methodsFor: 'waiting' stamp: 'crl 7/18/2011 02:05'!relinquishPhysicalProcessor	idleDelay wait! !!Flow methodsFor: 'sockets' stamp: 'crl 4/7/2007 13:51'!acceptFrom	| incomingClientTCPSocket |	incomingClientTCPSocket := (self resourceProxyForStackValue: 1) resource.	incomingClientTCPSocket		accept: incomingClientTCPSocket handle		from: (self resourceProxyForStackValue: 0) handle.	interpreterProxy pop: 2! !!Flow methodsFor: 'sockets' stamp: 'crl 7/5/2005 23:02'!closeSocket	"Close the socket corresponding to the handle on the parameters stack."	(self resourceProxyForStackValue: 0) close.	interpreterProxy pop: 1! !!Flow methodsFor: 'sockets' stamp: 'crl 7/7/2005 23:02'!connectSocketToAddress	| addressBytes addressBytesAddress |	addressBytes := ByteArray new: 6.	addressBytesAddress := (interpreterProxy stackObjectValue: 0) + 3.	1		to: 6		do: [:index |			addressBytes				at: index				put: (interpreterProxy byteAt: (addressBytesAddress + index))].	(self resourceProxyForStackValue: 1) connectToAddress: addressBytes.	interpreterProxy pop: 2! !!Flow methodsFor: 'sockets' stamp: 'crl 4/11/2007 15:46'!dataAvailableForSocket	| dataAvailable |	dataAvailable := (self resourceProxyForStackValue: 0) dataAvailable.	interpreterProxy		pop: 2;		pushBool: dataAvailable! !!Flow methodsFor: 'sockets' stamp: 'crl 11/2/2013 15:22'!enableSocketUsingTCP	"Enable the socket corresponding to the first parameter (a LargePositiveInteger), so that it uses TCP or UDP according to the second parameter (true or false)."	"In simulation, just make a proxy that uses a real instance of the class corresponding to that of the simulated receiver."	resourceProxies		at: (interpreterProxy signed32BitValueOf: (interpreterProxy stackObjectValue: 1))		put: (			ExternalResourceProxy				forResource: ((Smalltalk at: (interpreterProxy nameOfClass: (interpreterProxy fetchClassOf: (interpreterProxy stackObjectValue: 2))) asSymbol) new)				andSimulator: interpreterProxy).	interpreterProxy pop: 2! !!Flow methodsFor: 'sockets' stamp: 'crl 7/9/2005 21:42'!nameForIPAddressInto	| nameSource nameTargetAddress ipAddressSourceAddress ipAddressTarget |	nameTargetAddress := (interpreterProxy stackObjectValue: 0) + 3.	ipAddressSourceAddress := (interpreterProxy stackObjectValue: 1) + 3.	ipAddressTarget := ByteArray new: 4.		1		to: 4		do: [:index |			ipAddressTarget				at: index				put: (interpreterProxy byteAt: ipAddressSourceAddress + index)].	nameSource := String new: 64.	(SocketAddress new)		nameForIPAddress: ipAddressTarget		into: nameSource.	nameSource := nameSource asByteArray.	1		to: 64		do: [:index |			interpreterProxy				byteAt: nameTargetAddress + index				put: (nameSource at: index)].	interpreterProxy pop: 2! !!Flow methodsFor: 'sockets' stamp: 'crl 4/15/2007 10:33'!newSocketHandleInto	"Write the address of a new socket handle into the only parameter (a LargePositiveInteger)."	"For simulation, write a key into a dictionary of actual sockets."	interpreterProxy		storeLong32: 0		ofObject: (interpreterProxy stackObjectValue: 0)		withValue: nextSocketKey.	nextSocketKey := nextSocketKey + 1.	interpreterProxy pop: 1! !!Flow methodsFor: 'sockets' stamp: 'crl 7/7/2005 18:34'!nextFromTCPSocketIntoStartingAt	| resource quantityDesired quantityDelivered sourceBytes targetBytes |	resource := (self resourceProxyForStackValue: 2) resource.	quantityDesired := interpreterProxy stackIntegerValue: 3.	sourceBytes := ByteArray new: quantityDesired.	quantityDelivered := (		resource			next: quantityDesired			from: resource handle			into: sourceBytes			startingAt: 1).	targetBytes := (interpreterProxy stackObjectValue: 1) + 2 + (interpreterProxy stackIntegerValue: 0).	1		to: quantityDelivered		do: [:index |			interpreterProxy				byteAt: targetBytes + index				put: (sourceBytes at: index)].	interpreterProxy		pop: 4;		pushInteger: quantityDelivered! !!Flow methodsFor: 'sockets' stamp: 'crl 10/6/2005 10:33'!nextPutFromToTCPSocketStartingAt	| resourceProxy |	resourceProxy := self resourceProxyForStackValue: 1.	(resourceProxy == nil)		ifTrue: [interpreterProxy primitiveFail]		ifFalse: [			interpreterProxy				pop: 4				thenPush: (					resourceProxy						nextPut: (interpreterProxy stackIntegerValue: 3)						from: ((interpreterProxy stackObjectValue: 2) + 2 + (interpreterProxy stackIntegerValue: 0)))]! !!Flow methodsFor: 'sockets' stamp: 'crl 7/7/2005 20:03'!peerAddressIntoNameIntoTCPSocket	| address addressBytesSource hostnameSource addressBytesTarget hostnameTarget resource |	resource := (self resourceProxyForStackValue: 0) resource.	address := resource peerAddress.	addressBytesSource := address bytes.	hostnameSource := address hostname asByteArray.	addressBytesTarget := (interpreterProxy stackObjectValue: 2) + 3.	hostnameTarget := (interpreterProxy stackObjectValue: 1) + 3.	1		to: 6		do: [:index |			interpreterProxy				byteAt: addressBytesTarget + index				put: (addressBytesSource at: index)].	1		to: hostnameSource size		do: [:index |			interpreterProxy				byteAt: hostnameTarget + index				put: (hostnameSource at: index)].	interpreterProxy pop: 3! !!Flow methodsFor: 'sockets' stamp: 'crl 7/7/2005 18:17'!socketTimedOut	| resource |	resource := self resourceProxyForStackValue: 0.	interpreterProxy		pop: 2;		pushBool: resource timedOut! !!Flow methodsFor: 'sockets' stamp: 'crl 7/7/2005 23:31'!tcpSocketConnectionRefused	| connectionRefused |	connectionRefused := (self resourceProxyForStackValue: 0) connectionRefused.	interpreterProxy		pop: 1;		pushBool: connectionRefused ! !!Flow methodsFor: 'sockets' stamp: 'crl 7/9/2005 20:02'!tcpSocketIsActive	| isActive |	isActive := (self resourceProxyForStackValue: 0) isActive.	interpreterProxy		pop: 1;		pushBool: isActive! !!Flow methodsFor: 'marking' stamp: 'crl 2/12/2006 01:05'!clearMarkOnCompiledMethod	"Clear the activation mark on the parameter, a CompiledMethod."	| method flagByte oldIDByte |	method := interpreterProxy stackValue: 0.	flagByte := interpreterProxy byteAt: (method + 4 + (interpreterProxy byteLengthOf: method) - 1).	(flagByte < 252)		ifTrue: [			oldIDByte := interpreterProxy byteAt: (method + 4 + (interpreterProxy byteLengthOf: method) - 3 - flagByte).			interpreterProxy				byteAt: (method + 4 + (interpreterProxy byteLengthOf: method) - 3 - flagByte)				put: (oldIDByte bitAnd: 2r0111111)]		ifFalse: [			oldIDByte := interpreterProxy byteAt: (method + 4 + (interpreterProxy byteLengthOf: method) - 1 - 5).			interpreterProxy				byteAt: (method + 4 + (interpreterProxy byteLengthOf: method) - 1 - 5)				put: (oldIDByte bitAnd: 2r111111)].	interpreterProxy pop: 1! !!Flow methodsFor: 'marking' stamp: 'crl 12/30/2005 22:57'!compiledMethodIsMarked	"Answer whether the parameter, a CompiledMethod, has the activation mark."	| method flagByte idByte |	method := interpreterProxy stackValue: 0.	flagByte := interpreterProxy byteAt: (method + 4 + (interpreterProxy byteLengthOf: method) - 1).	idByte := (		(flagByte < 252)			ifTrue: [interpreterProxy byteAt: (method + 4 + (interpreterProxy byteLengthOf: method) - 3 - flagByte)]			ifFalse: [interpreterProxy byteAt: (method + 4 + (interpreterProxy byteLengthOf: method) - 1 - 5)]).	interpreterProxy		pop: 2;		pushBool: (idByte >= 128)! !!Flow methodsFor: 'marking' stamp: 'crl 2/12/2006 01:05'!compiledMethodMark	"Mark the parameter, a CompiledMethod, with the activation mark."	| method flagByte oldIDByte |	method := interpreterProxy stackValue: 0.	flagByte := interpreterProxy byteAt: (method + 4 + (interpreterProxy byteLengthOf: method) - 1).	(flagByte < 252)		ifTrue: [			oldIDByte := interpreterProxy byteAt: (method + 4 + (interpreterProxy byteLengthOf: method) - 3 - flagByte).			interpreterProxy				byteAt: (method + 4 + (interpreterProxy byteLengthOf: method) - 3 - flagByte)				put: ((oldIDByte bitAnd: 2r1111111) + 2r10000000)]		ifFalse: [			oldIDByte := interpreterProxy byteAt: (method + 4 + (interpreterProxy byteLengthOf: method) - 1 - 5).			interpreterProxy				byteAt: (method + 4 + (interpreterProxy byteLengthOf: method) - 1 - 5)				put: ((oldIDByte bitAnd: 2r1111111) + 2r10000000)].	interpreterProxy pop: 1! !!Flow methodsFor: 'external resources' stamp: 'crl 7/7/2005 22:28'!associateWithReadabilityIndexAndWritabilityIndex	"Associate the external resource corresponding to the first parameter (a LargePositiveInteger) with the semaphores corresponding to the external indices indicated by the second and third parameters (SmallIntegers)."	(resourceProxies at: (interpreterProxy signed32BitValueOf: (interpreterProxy stackObjectValue: 2)))		readabilityIndex: (interpreterProxy stackIntegerValue: 1)		writabilityIndex: (interpreterProxy stackIntegerValue: 0).	interpreterProxy pop: 3! !!Flow methodsFor: 'serving' stamp: 'crl 7/5/2005 23:03'!listenAtPortQueueSizeTCPSocket	"Make the given ServerTCPSocket listen at the given port with the given queueSize."	(		resourceProxies			at: (interpreterProxy signed32BitValueOf: (interpreterProxy stackObjectValue: 0))			ifAbsent: [self halt: 'no such socket']	)		listenAtPort: (interpreterProxy stackIntegerValue: 2)		queueSize: (interpreterProxy stackIntegerValue: 1).	interpreterProxy pop: 3! !!Flow methodsFor: 'utilities' stamp: 'crl 2/12/2006 10:21'!breakHere	self halt! !!Flow methodsFor: 'utilities' stamp: 'crl 1/5/2006 22:36'!noteMissingPrimitive: primitiveName	"Notify a human that the primitive for primitiveName is missing."	(primitiveName == #initializeUUID) ifFalse: [self halt: 'missing primitive: ', primitiveName]! !!Flow methodsFor: 'utilities' stamp: 'crl 10/6/2005 10:32'!resourceProxyForStackValue: index	"Answer the resource proxy corresponding to the handle the parameter stack value at index."	^resourceProxies at: (interpreterProxy signed32BitValueOf: (interpreterProxy stackObjectValue: index)) ifAbsent: [nil]! !!Flow methodsFor: 'initialization' stamp: 'crl 7/18/2011 02:05'!initialize	"Initialize myself."	resourceProxies := IdentityDictionary new.	nextSocketKey := 1.	idleDelay := Delay forMilliseconds: 20! !!Flow class methodsFor: 'instantiation' stamp: 'crl 4/26/2004 14:43'!new	"Answer a new initialized instance of myself."	^super new initialize! !!Interpreter methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 3/26/2003 12:54'!bytecodePrimClass	| rcvr rcvrClass |	rcvr := self internalStackTop.	rcvrClass := self fetchClassOf: rcvr.	(rcvrClass = (self splObj: ClassProxy)) ifFalse: [		self internalPop: 1 thenPush: rcvrClass.		^self fetchNextBytecode].	messageSelector := self specialSelector: 23.	argumentCount := 0.	self normalSend! !!Interpreter methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 3/26/2003 13:52'!bytecodePrimEquivalent	| rcvr rcvrClass arg |	rcvr := self internalStackValue: 1.	rcvrClass := self fetchClassOf: rcvr.	(rcvrClass = (self splObj: ClassProxy)) ifFalse: [		arg := self internalStackValue: 0.		^self booleanCheat: rcvr = arg].	messageSelector := self specialSelector: 22.	argumentCount := 1.	self normalSend! !!Interpreter methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 5/22/2011 08:36'!findNewMethodInClass: class 	"Find the compiled method to be run when the current 	messageSelector is sent to the given class, setting the values 	of 'newMethod' and 'primitiveIndex'."	<inline: false>	lastMethodWasCached := self lookupInMethodCacheSel: messageSelector class: class.	lastMethodWasCached		ifFalse: ["entry was not found in the cache; look it up the hard way "			self lookupMethodInClass: class.			lkupClass := class.			self addNewMethodToCache]! !!Interpreter methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 3/7/2012 11:36'!lookupMethodInClass: class	| currentClass dictionary found rclass theBytesPerWord flagByte oldIDByte |	<inline: false>	theBytesPerWord := self bytesPerWord.	(class = (self splObj: ClassProxy)) ifTrue: [		(messageSelector ~= (self splObj: SelectorInitProxy)) ifTrue: [			(messageSelector ~= (self splObj: SelectorProxyHash)) ifTrue: [				(messageSelector ~= (self splObj: SelectorForward)) ifTrue: [					(messageSelector ~= (self splObj: SelectorIsNil)) ifTrue: [						(messageSelector ~= (self splObj: SelectorNextInstance)) ifTrue: [							(messageSelector ~= (self splObj: SelectorCounterpart)) ifTrue: [								(messageSelector ~= (self splObj: SelectorStoreOnProxyStream)) ifTrue: [									self pushRemappableOop: class.  "may cause GC!!"									self createActualMessageTo: class.									rclass := self popRemappableOop.									messageSelector := self splObj: SelectorForward.									^self lookupMethodInClass: rclass]]]]]]]].	currentClass := class.	[currentClass ~= nilObj] whileTrue: [		dictionary := self fetchPointer: MessageDictionaryIndex ofObject: currentClass.		dictionary = nilObj ifTrue: [			"MethodDict pointer is nil (hopefully due a swapped out stub) -- raise exception #cannotInterpret:."			self pushRemappableOop: currentClass.  "may cause GC!!"			self createActualMessageTo: class.			currentClass := self popRemappableOop.			messageSelector := self splObj: SelectorCannotInterpret.			^self lookupMethodInClass: (self superclassOf: currentClass)].				found := self lookupMethodInDictionary: dictionary.		found ifTrue: [			(newMethod = nilObj)				ifTrue: [					(messageSelector = (self splObj: SelectorDoesNotUnderstand))						ifTrue: [currentClass := self superclassOf: currentClass]						ifFalse: [currentClass := nilObj]]				ifFalse: [					"Mark the newly-found method as having been used."					"Ensure that any object memory you run with this interpreter has the appropriate method trailer bytes."					flagByte := self byteAt: (newMethod + theBytesPerWord + (self byteLengthOf: newMethod) - 1).					(flagByte < 252)						ifTrue: [							oldIDByte := self byteAt: (newMethod + theBytesPerWord + (self byteLengthOf: newMethod) - 3 - flagByte).							self								byteAt: (newMethod + theBytesPerWord + (self byteLengthOf: newMethod) - 3 - flagByte)								put: (oldIDByte bitOr: 2r10000000)]						ifFalse: [							oldIDByte := self byteAt: (newMethod + theBytesPerWord + (self byteLengthOf: newMethod) - 1 - 5).							self								byteAt: (newMethod + theBytesPerWord + (self byteLengthOf: newMethod) - 1 - 5)								put: (oldIDByte bitOr: 2r10000000)].				^methodClass := currentClass]].				currentClass := self superclassOf: currentClass].	"Could not find #doesNotUnderstand: -- unrecoverable error."	messageSelector = (self splObj: SelectorDoesNotUnderstand) ifTrue:		[self error: 'Recursive not understood error encountered'].	"Cound not find a normal message -- raise exception #doesNotUnderstand:"	self pushRemappableOop: class.  "may cause GC!!"	self createActualMessageTo: class.	rclass := self popRemappableOop.	messageSelector := self splObj: SelectorDoesNotUnderstand.	^ self lookupMethodInClass: rclass! !!Interpreter class methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 5/23/2011 12:47'!initializePrimitiveTable 	"This table generates a C function address table use in primitiveResponse along with dispatchFunctionPointerOn:in:"	"NOTE: The real limit here is 2047 because of the method header layout but there is no point in going over the needed size"	MaxPrimitiveIndex := 575.	PrimitiveTable := Array new: MaxPrimitiveIndex + 1.	self table: PrimitiveTable from: 	#(	"Integer Primitives (0-19)"		(0 primitiveFail)		(1 primitiveAdd)		(2 primitiveSubtract)		(3 primitiveLessThan)		(4 primitiveGreaterThan)		(5 primitiveLessOrEqual)		(6 primitiveGreaterOrEqual)		(7 primitiveEqual)		(8 primitiveNotEqual)		(9 primitiveMultiply)		(10 primitiveDivide)		(11 primitiveMod)		(12 primitiveDiv)		(13 primitiveQuo)		(14 primitiveBitAnd)		(15 primitiveBitOr)		(16 primitiveBitXor)		(17 primitiveBitShift)		(18 primitiveMakePoint)		(19 primitiveFail)					"Guard primitive for simulation -- *must* fail"		"LargeInteger Primitives (20-39)"		(20 primitiveFail)		(21 primitiveAddLargeIntegers)		(22 primitiveSubtractLargeIntegers)		(23 primitiveLessThanLargeIntegers)		(24 primitiveGreaterThanLargeIntegers)		(25 primitiveLessOrEqualLargeIntegers)		(26 primitiveGreaterOrEqualLargeIntegers)		(27 primitiveEqualLargeIntegers)		(28 primitiveNotEqualLargeIntegers)		(29 primitiveMultiplyLargeIntegers)		(30 primitiveDivideLargeIntegers)		(31 primitiveModLargeIntegers)		(32 primitiveDivLargeIntegers)		(33 primitiveQuoLargeIntegers)		(34 primitiveBitAndLargeIntegers)		(35 primitiveBitOrLargeIntegers)		(36 primitiveBitXorLargeIntegers)		(37 primitiveBitShiftLargeIntegers)		(38 primitiveFail)		(39 primitiveFail)		"Float Primitives (40-59)"		(40 primitiveAsFloat)		(41 primitiveFloatAdd)		(42 primitiveFloatSubtract)		(43 primitiveFloatLessThan)		(44 primitiveFloatGreaterThan)		(45 primitiveFloatLessOrEqual)		(46 primitiveFloatGreaterOrEqual)		(47 primitiveFloatEqual)		(48 primitiveFloatNotEqual)		(49 primitiveFloatMultiply)		(50 primitiveFloatDivide)		(51 primitiveTruncated)		(52 primitiveFractionalPart)		(53 primitiveExponent)		(54 primitiveTimesTwoPower)		(55 primitiveSquareRoot)		(56 primitiveSine)		(57 primitiveArctan)		(58 primitiveLogN)		(59 primitiveExp)		"Subscript and Stream Primitives (60-67)"		(60 primitiveAt)		(61 primitiveAtPut)		(62 primitiveSize)		(63 primitiveStringAt)		(64 primitiveStringAtPut)		(65 primitiveFail) "was primitiveNext which no longer pays its way (normal Smalltalk code is faster)"		(66 primitiveFail) "was primitiveNextPut which no longer pays its way (normal Smalltalk code is faster)"		(67 primitiveFail) "was primitiveAtEnd which no longer pays its way (normal Smalltalk code is faster)"		"StorageManagement Primitives (68-79)"		(68 primitiveObjectAt)		(69 primitiveObjectAtPut)		(70 primitiveNew)		(71 primitiveNewWithArg)		(72 primitiveArrayBecomeOneWay)	"Blue Book: primitiveBecome"		(73 primitiveInstVarAt)		(74 primitiveInstVarAtPut)		(75 primitiveAsOop)		(76 primitiveStoreStackp)					"Blue Book: primitiveAsObject"		(77 primitiveSomeInstance)		(78 primitiveNextInstance)		(79 primitiveNewMethod)		"Control Primitives (80-89)"		(80 primitiveBlockCopy)		(81 primitiveValue)		(82 primitiveValueWithArgs)		(83 primitivePerform)		(84 primitivePerformWithArgs)		(85 primitiveSignal)		(86 primitiveWait)		(87 primitiveResume)		(88 primitiveSuspend)		(89 primitiveFlushCache)		"Input/Output Primitives (90-109)"		(90 primitiveMousePoint)		(91 primitiveTestDisplayDepth)			"Blue Book: primitiveCursorLocPut"		(92 primitiveSetDisplayMode)				"Blue Book: primitiveCursorLink"		(93 primitiveInputSemaphore)		(94 primitiveGetNextEvent)				"Blue Book: primitiveSampleInterval"		(95 primitiveInputWord)		(96 primitiveFail)	"primitiveCopyBits"		(97 primitiveSnapshot)		(98 primitiveStoreImageSegment)		(99 primitiveLoadImageSegment)		(100 primitivePerformInSuperclass)		"Blue Book: primitiveSignalAtTick"		(101 primitiveBeCursor)		(102 primitiveBeDisplay)		(103 primitiveScanCharacters)		(104 primitiveFail)	"primitiveDrawLoop"		(105 primitiveStringReplace)		(106 primitiveScreenSize)		(107 primitiveMouseButtons)		(108 primitiveKbdNext)		(109 primitiveKbdPeek)		"System Primitives (110-119)"		(110 primitiveEquivalent)		(111 primitiveClass)		(112 primitiveBytesLeft)		(113 primitiveQuit)		(114 primitiveExitToDebugger)		(115 primitiveChangeClass)					"Blue Book: primitiveOopsLeft"		(116 primitiveFlushCacheByMethod)		(117 primitiveExternalCall)		(118 primitiveDoPrimitiveWithArgs)		(119 primitiveFlushCacheSelective)			"Squeak 2.2 and earlier use 119.  Squeak 2.3 and later use 116.			Both are supported for backward compatibility."		"Miscellaneous Primitives (120-127)"		(120 primitiveCalloutToFFI)		(121 primitiveImageName)		(122 primitiveNoop)					"Blue Book: primitiveImageVolume"		(123 primitiveValueUninterruptably)	"@@@: Remove this when all VMs have support"		(124 primitiveLowSpaceSemaphore)		(125 primitiveSignalAtBytesLeft)		"Squeak Primitives Start Here"		"Squeak Miscellaneous Primitives (128-149)"		(126 primitiveDeferDisplayUpdates)		(127 primitiveShowDisplayRect)		(128 primitiveArrayBecome)		(129 primitiveSpecialObjectsOop)		(130 primitiveFullGC)		(131 primitiveIncrementalGC)		(132 primitiveObjectPointsTo)		(133 primitiveSetInterruptKey)		(134 primitiveInterruptSemaphore)		(135 primitiveMillisecondClock)		(136 primitiveSignalAtMilliseconds)		(137 primitiveSecondsClock)		(138 primitiveSomeObject)		(139 primitiveNextObject)		(140 primitiveBeep)		(141 primitiveClipboardText)		(142 primitiveVMPath)		(143 primitiveShortAt)		(144 primitiveShortAtPut)		(145 primitiveConstantFill)		"NOTE: When removing the obsolete indexed primitives,		the following two should go become #primitiveIntegerAt / atPut"		(146 primitiveFail)	"primitiveReadJoystick"		(147 primitiveFail)	"primitiveWarpBits"		(148 primitiveClone)		(149 primitiveGetAttribute)		"File Primitives (150-169) - NO LONGER INDEXED"		(150 159 primitiveFail)		(160 primitiveAdoptInstance)		(161 164 primitiveFail)		(165 primitiveIntegerAt)		"hacked in here for now"		(166 primitiveIntegerAtPut)		(167 primitiveYield)		(168 primitiveCopyObject)		(169 primitiveFail)		"Sound Primitives (170-199) - NO LONGER INDEXED"		(170 185 primitiveFail)		"Old closure primitives"		(186 primitiveFail) "was primitiveClosureValue"		(187 primitiveFail) "was primitiveClosureValueWithArgs"		"Perform method directly"		(188 primitiveExecuteMethodArgsArray)		(189 primitiveExecuteMethod)		"Sound Primitives (continued) - NO LONGER INDEXED"		(190 194 primitiveFail)		"Unwind primitives"		(195 primitiveFindNextUnwindContext)		(196 primitiveTerminateTo)		(197 primitiveFindHandlerContext)		(198 primitiveMarkUnwindMethod)		(199 primitiveMarkHandlerMethod)		"new closure primitives (were Networking primitives)"		(200 primitiveClosureCopyWithCopiedValues)		(201 primitiveClosureValue) "value"		(202 primitiveClosureValue) "value:"		(203 primitiveClosureValue) "value:value:"		(204 primitiveClosureValue) "value:value:value:"		(205 primitiveClosureValue) "value:value:value:value:"		(206 primitiveClosureValueWithArgs) "valueWithArguments:"		(207 209 primitiveFail) "reserved for Cog primitives"		(210 primitiveAt)		"Compatibility with Cog StackInterpreter Context primitives"		(211 primitiveAtPut)	"Compatibility with Cog StackInterpreter Context primitives"		(212 primitiveSize)	"Compatibility with Cog StackInterpreter Context primitives"		(213 219 primitiveFail) "reserved for Cog primitives"		(220 primitiveFail)		"reserved for Cog primitives"		(221 primitiveClosureValueNoContextSwitch) "valueNoContextSwitch"		(222 primitiveClosureValueNoContextSwitch) "valueNoContextSwitch:"		(223 229 primitiveFail)	"reserved for Cog primitives"		(230 primitiveRelinquishProcessor)		(231 primitiveForceDisplayUpdate)		(232 primitiveFormPrint)		(233 primitiveSetFullScreen)		(234 primitiveFail) "primBitmapdecompressfromByteArrayat"		(235 primitiveFail) "primStringcomparewithcollated"		(236 primitiveFail) "primSampledSoundconvert8bitSignedFromto16Bit"		(237 primitiveFail) "primBitmapcompresstoByteArray"		(238 241 primitiveFail) "serial port primitives"		(242 primitiveFail)		(243 primitiveFail) "primStringtranslatefromtotable"		(244 primitiveFail) "primStringfindFirstInStringinSetstartingAt"		(245 primitiveFail) "primStringindexOfAsciiinStringstartingAt"		(246 primitiveFail) "primStringfindSubstringinstartingAtmatchTable"		(247 primitiveSnapshotEmbedded)		(248 primitiveInvokeObjectAsMethod)		(249 primitiveArrayBecomeOneWayCopyHash)		"VM Implementor Primitives (250-255)"		(250 clearProfile)		(251 dumpProfile)		(252 startProfiling)		(253 stopProfiling)		(254 primitiveVMParameter)		(255 primitiveInstVarsPutFromStack) "Never used except in Disney tests.  Remove after 2.3 release."		"Quick Push Const Methods"		(256 primitivePushSelf)		(257 primitivePushTrue)		(258 primitivePushFalse)		(259 primitivePushNil)		(260 primitivePushMinusOne)		(261 primitivePushZero)		(262 primitivePushOne)		(263 primitivePushTwo)		"Quick Push Const Methods"		(264 519 primitiveLoadInstVar)		"These ranges used to be used by obsiolete indexed primitives."		(520 529 primitiveFail)		(530 539 primitiveFail)		(540 549 primitiveFail)		(550 559 primitiveFail)		(560 569 primitiveFail)		"External primitive support primitives"		(570 primitiveFlushExternalPrimitives)		(571 primitiveUnloadModule)		(572 primitiveListBuiltinModule)		(573 primitiveListExternalModule)		(574 primitiveFail) "reserved for addl. external support prims"		"Unassigned Primitives"		(575 primitiveSnapshotWithoutStaleMethods)).! !!InterpreterSimulator methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 7/18/2011 22:37'!lookupMethodInClass: class	| currentClass dictionary found rclass flagByte oldIDByte |	"((self shortPrint: messageSelector) = '#open') ifTrue: [self halt]."	(class = (self splObj: ClassProxy)) ifTrue: [		(messageSelector ~= (self splObj: SelectorInitProxy)) ifTrue: [			(messageSelector ~= (self splObj: SelectorProxyHash)) ifTrue: [				(messageSelector ~= (self splObj: SelectorForward)) ifTrue: [					(messageSelector ~= (self splObj: SelectorIsNil)) ifTrue: [						(messageSelector ~= (self splObj: SelectorNextInstance)) ifTrue: [							(messageSelector ~= (self splObj: SelectorCounterpart)) ifTrue: [								(messageSelector ~= (self splObj: SelectorStoreOnProxyStream)) ifTrue: [									self pushRemappableOop: class.  "may cause GC!!"									self createActualMessageTo: class.									rclass := self popRemappableOop.									messageSelector := self splObj: SelectorForward.									^self lookupMethodInClass: rclass]]]]]]]].	currentClass := class.	[currentClass ~= nilObj] whileTrue: [		dictionary := self fetchPointer: MessageDictionaryIndex ofObject: currentClass.		dictionary = nilObj ifTrue: [			"MethodDict pointer is nil (hopefully due to a swapped out stub); raise exception #cannotInterpret:."			"Creating a Message may cause a garbage collection."			self pushRemappableOop: currentClass.			self createActualMessageTo: class.			currentClass := self popRemappableOop.			messageSelector := self splObj: SelectorCannotInterpret.			^self lookupMethodInClass: (self superclassOf: currentClass)].		found := self lookupMethodInDictionary: dictionary.		found			ifTrue: [				(newMethod = nilObj)					ifTrue: [						(messageSelector = (self splObj: SelectorDoesNotUnderstand))							ifTrue: [currentClass := self superclassOf: currentClass]							ifFalse: [currentClass := nilObj]]					ifFalse: [						"Mark the newly-found method as having been used."						"flagByte := self byteAt: (newMethod + 4 + (self byteLengthOf: newMethod) - 1).						(flagByte < 252)							ifTrue: [								oldIDByte := self byteAt: (newMethod + 4 + (self byteLengthOf: newMethod) - 3 - flagByte).								self									byteAt: (newMethod + 4 + (self byteLengthOf: newMethod) - 3 - flagByte)									put: (oldIDByte bitOr: 2r10000000)]							ifFalse: [								oldIDByte := self byteAt: (newMethod + 4 + (self byteLengthOf: newMethod) - 1 - 5).								self									byteAt: (newMethod + 4 + (self byteLengthOf: newMethod) - 1 - 5)									put: (oldIDByte bitOr: 2r10000000)]."					 ^methodClass := currentClass]]			ifFalse: [currentClass := self superclassOf: currentClass]].	"Could not find #doesNotUnderstand:; unrecoverable error."	messageSelector = (self splObj: SelectorDoesNotUnderstand) ifTrue: [self error: 'Recursive not-understood error encountered'].	"Cound not find a normal message; raise exception #doesNotUnderstand:"	"Creating a Message may cause a garbage collection."	self pushRemappableOop: class.	self createActualMessageTo: class.	rclass := self popRemappableOop.	Transcript cr; cr; nextPutAll: 'An instance of '; nextPutAll: (self shortPrint: class); nextPutAll: ' didn''t understand '; nextPutAll: (self shortPrint: messageSelector); cr; nextPutAll: self printStack; cr; cr; endEntry; halt.	messageSelector := self splObj: SelectorDoesNotUnderstand.	^self lookupMethodInClass: rclass! !!Other class methodsFor: 'as yet unclassified' stamp: 'crl 8/21/2012 00:32'!withRemoteIdentity: aSmallInteger andSession: aRemoteMessagingSession	"Answer a new instance of myself which which corresponds to the remote object with identity aSmallInteger, reachable via aRemoteMessagingSession's network connections."	| proxyHashValue |	proxyHashValue := aSmallInteger + aRemoteMessagingSession hash.	^self		firstInstanceSuchThat: [:other | other proxyHash = proxyHashValue]		ifNone: [			(self basicNew)				remoteIdentity: aSmallInteger				session: aRemoteMessagingSession]! !!SmalltalkImage methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 8/20/2012 17:45'!recreateSpecialObjectsArray	| t1 |	t1 := Array new: 121.	t1 at: 1 put: nil.	t1 at: 2 put: false.	t1 at: 3 put: true.	t1		at: 4		put: (self associationAt: #Processor).	t1 at: 5 put: Bitmap.	t1 at: 6 put: SmallInteger.	t1 at: 7 put: ByteString.	t1 at: 8 put: Array.	t1 at: 9 put: Smalltalk.	t1 at: 10 put: Float.	t1 at: 11 put: MethodContext.	t1 at: 12 put: BlockContext.	t1 at: 13 put: Point.	t1 at: 14 put: LargePositiveInteger.	t1 at: 15 put: Display.	t1 at: 16 put: Message.	t1 at: 17 put: CompiledMethod.	t1		at: 18		put: (self specialObjectsArray at: 18).	t1 at: 19 put: Semaphore.	t1 at: 20 put: Character.	t1 at: 21 put: #doesNotUnderstand:.	t1 at: 22 put: #cannotReturn:.	t1 at: 23 put: nil.	t1 at: 24 put: #(#+ 1 #- 1 #< 1 #> 1 #<= 1 #>= 1 #= 1 #~= 1 #* 1 #/ 1 #\\ 1 #@ 1 #bitShift: 1 #// 1 #bitAnd: 1 #bitOr: 1 #at: 1 #at:put: 2 #size 0 #next 0 #nextPut: 1 #atEnd 0 #== 1 #class 0 #blockCopy: 1 #value 0 #value: 1 #do: 1 #new 0 #new: 1 #x 0 #y 0 ).	t1		at: 25		put: (self specialObjectsArray at: 25).	t1 at: 26 put: #mustBeBoolean.	t1 at: 27 put: ByteArray.	t1 at: 28 put: Process.	t1 at: 29 put: self compactClassesArray.	t1		at: 30		put: (self specialObjectsArray at: 30).	t1		at: 31		put: (self specialObjectsArray at: 31).	t1		at: 32		put: (Float new: 2).	t1		at: 33		put: (LargePositiveInteger new: 4).	t1 at: 34 put: Point new.	t1 at: 35 put: #cannotInterpret:.	t1		at: 36		put: (self specialObjectsArray at: 36).	t1 at: 37 put: BlockClosure.	t1		at: 38		put: (self specialObjectsArray at: 38).	t1		at: 39		put: (self specialObjectsArray at: 39).	t1 at: 40 put: nil.	t1 at: 41 put: nil.	t1		at: 42		put: ((self specialObjectsArray at: 42)				ifNil: [Semaphore new]).	t1 at: 43 put: LargeNegativeInteger.	t1		at: 44		put: (self				at: #ExternalAddress				ifAbsent: []).	t1		at: 45		put: (self				at: #ExternalStructure				ifAbsent: []).	t1		at: 46		put: (self				at: #ExternalData				ifAbsent: []).	t1		at: 47		put: (self				at: #ExternalFunction				ifAbsent: []).	t1		at: 48		put: (self				at: #ExternalLibrary				ifAbsent: []).	t1 at: 49 put: #aboutToReturn:through:.	t1 at: 50 put: #run:with:in:.	t1 at: 52 put: #(nil #'bad receiver' #'bad argument' #'bad index' #'bad number of arguments' #'inappropriate operation' #'unsupported operation' #'no modification' #'insufficient object memory' #'insufficient C memory' #'not found' #'bad method' #'internal error in named primitive machinery' #'object may move' ).	t1		at: 53		put: (self				at: #Alien				ifAbsent: []).	t1 at: 54 put: #invokeCallback:stack:registers:jmpbuf:.	t1		at: 55		put: (self				at: #UnsafeAlien				ifAbsent: []).	t1		at: 56		put: (self				at: #WeakFinalizationList				ifAbsent: []).	t1 at: 108 put: Other;		 at: 109 put: #forward:;		 at: 110 put: #remoteIdentity:session:;		 at: 111 put: #proxyHash;		 at: 112 put: #counterpart;		 at: 113 put: #isNil;		 at: 114 put: #nextInstance;		 at: 115 put: #storeOnProxyStream:for:;		 at: 116 put: #startReportingSends;				at: 117		put: (self specialObjectsArray at: 117);				at: 118		put: (self specialObjectsArray at: 118);		 at: 119 put: #stopReportingSends;		 at: 120 put: #unreportedWait;		 at: 121 put: #unreportedSignal.	self specialObjectsArray become: t1! !