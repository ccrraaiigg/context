'From Squeak4.2 of 4 February 2011 [latest update: #10966] on 2 November 2013 at 3:36:46 pm'!Object subclass: #ObjectMemory	instanceVariableNames: 'memory youngStart endOfMemory memoryLimit nilObj falseObj trueObj specialObjectsOop rootTable rootTableCount extraRoots extraRootCount weakRoots weakRootCount child field parentField freeBlock lastHash allocationCount lowSpaceThreshold signalLowSpace compStart compEnd fwdTableNext fwdTableLast remapBuffer remapBufferCount allocationsBetweenGCs tenuringThreshold gcSemaphoreIndex gcBiasToGrow gcBiasToGrowGCLimit gcBiasToGrowThreshold statFullGCs statFullGCMSecs statIncrGCs statIncrGCMSecs statTenures statRootTableOverflows freeContexts freeLargeContexts interruptCheckCounter totalObjectCount shrinkThreshold growHeadroom headerTypeBytes youngStartLocal statMarkCount statSweepCount statMkFwdCount statCompMoveCount statGrowMemory statShrinkMemory statRootTableCount statAllocationCount statSurvivorCount statGCTime statSpecialMarkCount statIGCDeltaTime statpendingFinalizationSignals forceTenureFlag'	classVariableNames: 'BlockContextProto Byte0Mask Byte0Shift Byte1Mask Byte1Shift Byte1ShiftNegated Byte2Mask Byte2Shift Byte3Mask Byte3Shift Byte3ShiftNegated Byte4Mask Byte4Shift Byte4ShiftNegated Byte5Mask Byte5Shift Byte5ShiftNegated Byte6Mask Byte6Shift Byte7Mask Byte7Shift Byte7ShiftNegated Bytes3to0Mask Bytes7to4Mask ClassPseudoContext ClassTranslatedMethod ContextFixedSizePlusHeader DoAssertionChecks DoBalanceChecks Done ExtraRootSize GCTopMarker HashBits HeaderTypeClass HeaderTypeFree HeaderTypeGC InvokeCallbackSelector MethodContextProto MethodToReport NilContext RemapBufferSize ReportedMethodID RootTableRedZone RootTableSize StackStart StartField StartObj Upward'	poolDictionaries: 'VMObjectIndices VMSqueakV3BytecodeConstants VMSqueakV3ObjectRepresentationConstants'	category: 'VMMaker-Interpreter'!!ObjectMemory methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 3/27/2006 21:11'!isNotStaleMethod: oop	| flagByte idByte |	(((oop bitAnd: 1) > 0) or: [(((self baseHeader: oop) >> 12) bitAnd: 16r1F) ~= 1]) ifTrue: [^true].	"Assume that all methods associated with contexts have been marked."	flagByte := self byteAt: (oop + 4 + (self byteLengthOf: oop) - 1).	(flagByte < 252)		ifTrue: [idByte := self byteAt: (oop + 4 + (self byteLengthOf: oop) - 3 - flagByte)]		ifFalse: [idByte := self byteAt: (oop + 4 + (self byteLengthOf: oop) - 1 - 5)].	^idByte >= 2r10000000! !!ObjectMemory methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 5/22/2011 06:32'!markAndTraceDiscardingStaleMethods: oop	"Mark all objects reachable from the given one.	Trace from the given object even if it is old.	Do not trace if it is already marked.	Mark it only if it is a young object."	"Tracer state variables:		child		object being examined		field		next field of child to examine		parentField	field where child was stored in its referencing object"	| header lastFieldOffset action statMarkCountLocal |	header := self longAt: oop.	(header bitAnd: self markBit) = 0 ifFalse: [^ 0  "already marked"].	"record tracing status in object's header"	header := (header bitAnd: self allButTypeMask) bitOr: HeaderTypeGC.	(self oop: oop isGreaterThanOrEqualTo: youngStart)		ifTrue: [ header := header bitOr: self markBit ].  "mark only if young"	self longAt: oop put: header.	"initialize the tracer state machine"	parentField := GCTopMarker.	child := oop.	(self isWeakNonInt: oop) ifTrue: [		"Set lastFieldOffset before the weak fields in the receiver"		lastFieldOffset := (self nonWeakFieldsOf: oop) << self shiftForWord.		"And remember as weak root"		weakRootCount := weakRootCount + 1.		weakRoots at: weakRootCount put: oop.	] ifFalse: [		"Do it the usual way"		lastFieldOffset := self lastPointerOf: oop.	].	field := oop + lastFieldOffset.	action := StartField.	youngStartLocal := youngStart.	statMarkCountLocal := statMarkCount.	"run the tracer state machine until all objects reachable from oop are marked"	[action = Done] whileFalse: [		statMarkCountLocal := statMarkCountLocal + 1.		action = StartField ifTrue: [ action := self startField ].		action = StartObj ifTrue: [ action := self startObj ].		action = Upward ifTrue: [ action := self upwardDiscardingStaleMethods ].	].	statMarkCount := statMarkCountLocal.! !!ObjectMemory methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 5/22/2011 06:34'!markPhaseDiscardingStaleMethods	"Mark phase of the mark and sweep garbage collector. Set 	the mark bits of all reachable objects. Free chunks are 	untouched by this process."	"Assume: All non-free objects are initially unmarked. Root 	objects were unmarked when they were made roots. (Make 	sure this stays true!!!!)."	| oop |	<inline: false>	"clear the recycled context lists"	freeContexts := NilContext.	freeLargeContexts := NilContext.	"trace the interpreter's objects, including the active stack 	and special objects array"	self markAndTraceInterpreterOopsDiscardingStaleMethods.	statSpecialMarkCount := statMarkCount.	"trace the roots"	1 to: rootTableCount do: [:i | 			oop := rootTable at: i.			self markAndTraceDiscardingStaleMethods: oop].	1 to: extraRootCount do:[:i|			oop := (extraRoots at: i) at: 0.			(self isIntegerObject: oop) ifFalse:[self markAndTraceDiscardingStaleMethods: oop]].! !!ObjectMemory methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 5/22/2011 06:39'!upwardDiscardingStaleMethods	"Return from marking an object below. Incoming: 	field = oop we just worked on, needs to be put away 	parentField = where to put it in our object 	NOTE: Type field of object below has already been restored!!!!!! "	| type header |	<inline: true>	(parentField bitAnd: 1) = 1		ifTrue: [parentField = GCTopMarker				ifTrue: ["top of the chain"					header := (self longAt: field) bitAnd: self allButTypeMask.					type := self rightType: header.					self longAt: field put: (header bitOr: type). "install type on class oop"					^ Done]				ifFalse: ["was working on the extended class word"					child := field. "oop of class"					field := parentField - 1. "class word, ** clear the low bit **"					parentField := self longAt: field.					header := self longAt: field + self bytesPerWord. "base header word"					type := self rightType: header.					self longAt: field put: (child bitOr: type). "install type on class oop"					field := field + self bytesPerWord. "point at header"					"restore type bits"					header := header bitAnd: self allButTypeMask.					self longAt: field put: (header bitOr: type).					^ Upward]]		ifFalse: ["normal"			child := field. "who we worked on below"			field := parentField. "where to put it"			parentField := self longAt: field.			(self isNotStaleMethod: child)				ifTrue: [self longAt: field put: child]				ifFalse: [self longAt: field put: nilObj].			field := field - self bytesPerWord. "point at header"			^ StartField]! !!ObjectMemory methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 5/22/2011 06:25'!lastPointerOf: oop 	"Return the byte offset of the last pointer field of the given object.  	Works with CompiledMethods, as well as ordinary objects. 	Can be used even when the type bits are not correct."	| fmt sz methodHeader header contextSize |	<inline: true>	header := self baseHeader: oop.	fmt := header >> 8 bitAnd: 15.		"Use format 5 for marked method dictionaries."	fmt <= 5 ifTrue: [((fmt = 3 or: [fmt = 5]) and: [self isContextHeader: header])					ifTrue: ["contexts end at the stack pointer"						contextSize := self fetchStackPointerOf: oop.						^ CtxtTempFrameStart + contextSize * self bytesPerWord].				sz := self sizeBitsOfSafe: oop.				^ sz - self baseHeaderSize  "all pointers"].	fmt < 12 ifTrue: [^ 0]. "no pointers"	"CompiledMethod: contains both pointers and bytes:"	methodHeader := self longAt: oop + self baseHeaderSize.	^ (methodHeader >> 10 bitAnd: 255) * self bytesPerWord + self baseHeaderSize! !!ObjectMemory methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 10/25/2006 15:16'!isPointersNonInt: oop	"Answer true if the argument has only fields that can hold oops. See comment in formatOf:"	"Use format 5 for marked method dictionaries."	^ (self formatOf: oop) <= 5! !!ObjectMemory methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 5/26/2011 19:22'!fullGCDiscardingStaleMethods	"Do a mark/sweep garbage collection of the entire object memory. Free inaccessible objects but do not move them."	| startTime |	<inline: false>	<var: #startTime type: 'sqLong'>	DoAssertionChecks ifTrue: [self reverseDisplayFrom: 0 to: 7].	self preGCAction: true.	startTime := self ioMicroSecondClock.	statSweepCount := statMarkCount := statMkFwdCount := statCompMoveCount := 0.	self clearRootsTable.	youngStart := self startOfMemory.  "process all of memory"	self markPhaseDiscardingStaleMethods.	"Sweep phase returns the number of survivors.	Use the up-to-date version instead the one from startup."	totalObjectCount := self sweepPhase.	self fullCompaction.	allocationCount := 0.	statFullGCs := statFullGCs + 1.	statGCTime := self ioMicroSecondClock.	statFullGCMSecs := statFullGCMSecs + (statGCTime - startTime).	self capturePendingFinalizationSignals.	youngStart := freeBlock.  "reset the young object boundary"	self postGCAction.	DoAssertionChecks ifTrue: [self reverseDisplayFrom: 0 to: 7].! !!ObjectMemory methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 5/22/2011 06:29'!lastPointerWhileForwarding: oop 	"The given object may have its header word in a forwarding block. Find  	the offset of the last pointer in the object in spite of this obstacle. "	| header fwdBlock fmt size methodHeader contextSize |	<inline: true>	header := self longAt: oop.	(header bitAnd: self markBit) ~= 0		ifTrue: ["oop is forwarded; get its real header from its forwarding table entry"			fwdBlock := (header bitAnd: self allButMarkBitAndTypeMask) << 1.			DoAssertionChecks				ifTrue: [self fwdBlockValidate: fwdBlock].			header := self longAt: fwdBlock + self bytesPerWord].	fmt := header >> 8 bitAnd: 15.		"Use format 5 for marked method dictionaries."	fmt <= 5		ifTrue: [((fmt = 3 or: [fmt = 5]) and: [self isContextHeader: header])				ifTrue: ["contexts end at the stack pointer"					contextSize := self fetchStackPointerOf: oop.					^ CtxtTempFrameStart + contextSize * self bytesPerWord].			"do sizeBitsOf: using the header we obtained"			(header bitAnd: TypeMask) = HeaderTypeSizeAndClass				ifTrue: [size := (self sizeHeader: oop) bitAnd: self allButTypeMask]				ifFalse: [size := header bitAnd: self sizeMask].			^ size - self baseHeaderSize].	fmt < 12 ifTrue: [^ 0]. "no pointers"	methodHeader := self longAt: oop + self baseHeaderSize.	^ (methodHeader >> 10 bitAnd: 255) * self bytesPerWord + self baseHeaderSize! !!Interpreter methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 5/25/2011 15:52'!commonVariable: rcvr at: index put: value cacheIndex: atIx	"This code assumes the receiver has been identified at location atIx in the atCache."	| stSize fmt fixedFields valToPut |	<inline: true>	stSize := atCache at: atIx+AtCacheSize.	((self oop: index isGreaterThanOrEqualTo: 1)		and: [self oop: index isLessThanOrEqualTo: stSize])	ifTrue:		[fmt := atCache at: atIx+AtCacheFmt.		"Use format 5 for marked method dictionaries."		fmt <= 5 ifTrue:			[fixedFields := atCache at: atIx+AtCacheFixedFields.			^ self storePointer: index + fixedFields - 1 ofObject: rcvr withValue: value].		fmt < 8 ifTrue:  "Bitmap"			[valToPut := self positive32BitValueOf: value.			self successful ifTrue: [self storeLong32: index - 1 ofObject: rcvr withValue: valToPut].			^ nil].		fmt >= 16  "Note fmt >= 16 is an artificial flag for strings"			ifTrue: [valToPut := self asciiOfCharacter: value.					self successful ifFalse: [^ nil]]			ifFalse: [valToPut := value].		(self isIntegerObject: valToPut) ifTrue:			[valToPut := self integerValueOf: valToPut.			((valToPut >= 0) and: [valToPut <= 255]) ifFalse: [^ self primitiveFail].			^ self storeByte: index - 1 ofObject: rcvr withValue: valToPut]].	self primitiveFail! !!Interpreter methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 5/22/2011 08:19'!commonVariableInternal: rcvr at: index cacheIndex: atIx 	"This code assumes the receiver has been identified at location atIx in the atCache."	| stSize fmt fixedFields result |	<inline: true>	stSize := atCache at: atIx+AtCacheSize.	((self oop: index isGreaterThanOrEqualTo: 1)		and: [self oop: index isLessThanOrEqualTo: stSize])	ifTrue:		[fmt := atCache at: atIx+AtCacheFmt.		"Use format 5 for marked method dictionaries."		fmt <= 5 ifTrue:			[fixedFields := atCache at: atIx+AtCacheFixedFields.			^ self fetchPointer: index + fixedFields - 1 ofObject: rcvr].		fmt < 8 ifTrue:  "Bitmap"			[result := self fetchLong32: index - 1 ofObject: rcvr.			self externalizeIPandSP.			result := self positive32BitIntegerFor: result.			self internalizeIPandSP.			^ result].		fmt >= 16  "Note fmt >= 16 is an artificial flag for strings"			ifTrue: "String"			[^ self characterForAscii: (self fetchByte: index - 1 ofObject: rcvr)]			ifFalse: "ByteArray"			[^ self integerObjectOf: (self fetchByte: index - 1 ofObject: rcvr)]].	self primitiveFail! !!Interpreter methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 5/23/2011 12:40'!subscript: array with: index format: fmt	"Note: This method assumes that the index is within bounds!!"	<inline: true>	"Use format 5 for marked method dictionaries."	fmt <= 5 ifTrue: [  "pointer type objects"		^ self fetchPointer: index - 1 ofObject: array].	fmt < 8 ifTrue: [  "long-word type objects"		^ self positive32BitIntegerFor:			(self fetchLong32: index - 1 ofObject: array)	] ifFalse: [  "byte-type objects"		^ self integerObjectOf:			(self fetchByte: index - 1 ofObject: array)	].! !!Interpreter methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 5/25/2011 15:54'!subscript: array with: index storing: oopToStore format: fmt 	"Note: This method assumes that the index is within bounds!!"	| valueToStore |	<inline: true>	"Use format 5 for marked method dictionaries."	fmt <= 5		ifTrue: ["pointer type objects"			self storePointer: index - 1 ofObject: array				withValue: oopToStore]		ifFalse: [fmt < 8				ifTrue: ["long-word type objects"					valueToStore := self positive32BitValueOf: oopToStore.					self successful						ifTrue: [self storeLong32: index - 1 ofObject: array									withValue: valueToStore]]				ifFalse: ["byte-type objects"					(self isIntegerObject: oopToStore)						ifFalse: [primFailCode := 1].					valueToStore := self integerValueOf: oopToStore.					(valueToStore >= 0							and: [valueToStore <= 255])						ifFalse: [primFailCode := 1].					(self successful)						ifTrue: [self								storeByte: index - 1								ofObject: array								withValue: valueToStore]]]! !!Interpreter methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 5/23/2011 12:10'!markAllActiveMethods	"Mark all methods associated with contexts."	| methodContextClass oop blockContextClass |	methodContextClass := self splObj: ClassMethodContext.	blockContextClass := self splObj: ClassBlockContext.	oop := self firstObject.	[self oop: oop isLessThan: endOfMemory] whileTrue: [		| oopClass |		oopClass := self fetchClassOf: oop.		((oopClass = methodContextClass) or: [oopClass = blockContextClass]) ifTrue: [			| meth flagByte pointer index |			(oopClass = blockContextClass)				ifTrue: [pointer := HomeIndex]				ifFalse: [pointer := MethodIndex].			meth := (				self					fetchPointer: pointer					ofObject: oop).			meth = nilObj ifFalse: [				flagByte := self byteAt: (meth + 4 + (self byteLengthOf: meth) - 1).				(flagByte < 252)					ifTrue: [index := meth + 4 + (self byteLengthOf: meth) - 3 - flagByte]					ifFalse: [index := meth + 4 + (self byteLengthOf: meth) - 1 - 5].				self					byteAt: index					put: ((self byteAt: index) bitOr: 2r10000000)]].		oop := self objectAfter: oop]! !!Interpreter methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 5/25/2011 10:48'!snapshotWithoutStaleMethods	"update state of active context"	| activeProc dataSize rcvr setMacType |	<var: #setMacType type: 'void *'>	compilerInitialized		ifTrue: [self compilerPreSnapshot]		ifFalse: [self storeContextRegisters: activeContext].	"update state of active process"	activeProc := self fetchPointer: ActiveProcessIndex ofObject: self schedulerPointer.	self		storePointer: SuspendedContextIndex		ofObject: activeProc		withValue: activeContext.	"compact memory and compute the size of the memory actually in use"	self markAllActiveMethods.	self incrementalGC.	"maximimize space for forwarding table"	self fullGCDiscardingStaleMethods.	self snapshotCleanUp.	dataSize := freeBlock - self startOfMemory. "Assume all objects are below the start of the free block"	self successful		ifTrue: [rcvr := self popStack.			"pop rcvr"			self push: trueObj.			self writeImageFile: dataSize.			"set Mac file type and creator; this is a noop on other platforms"			setMacType := self ioLoadFunction: 'setMacFileTypeAndCreator' From: 'FilePlugin'.			setMacType = 0 ifFalse: [self cCode: '((sqInt (*)(char *, char *, char *))setMacType)(imageName, "STim", "FAST")'].			self pop: 1].	"activeContext was unmarked in #snapshotCleanUp, mark it old "	self beRootIfOld: activeContext.	self successful		ifTrue: [self push: falseObj]		ifFalse: [self push: rcvr].	compilerInitialized		ifTrue: [self compilerPostSnapshot]! !!Interpreter methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 5/23/2011 12:08'!lookupMethodInDictionary: dictionary 	"This method lookup tolerates integers as Dictionary keys to 	support execution of images in which Symbols have been 	compacted out"	| length index mask wrapAround nextSelector methodArray |	<inline: true>	length := self fetchWordLengthOf: dictionary.	mask := length - SelectorStart - 1.	(self isIntegerObject: messageSelector)		ifTrue: [index := (mask bitAnd: (self integerValueOf: messageSelector)) + SelectorStart]		ifFalse: [index := (mask bitAnd: (self hashBitsOf: messageSelector)) + SelectorStart].	"It is assumed that there are some nils in this dictionary, and search will 	stop when one is encountered. However, if there are no nils, then wrapAround 	will be detected the second time the loop gets to the end of the table."	wrapAround := false.	[true]		whileTrue: [nextSelector := self fetchPointer: index ofObject: dictionary.			nextSelector = nilObj ifTrue: [^ false].			nextSelector = messageSelector				ifTrue: [methodArray := self fetchPointer: MethodArrayIndex ofObject: dictionary.					newMethod := self fetchPointer: index - SelectorStart ofObject: methodArray.					"Check if newMethod is a CompiledMethod."					(self isCompiledMethod: newMethod)						ifTrue: [primitiveIndex := self primitiveIndexOf: newMethod.							primitiveIndex > MaxPrimitiveIndex								ifTrue: ["If primitiveIndex is out of range, set to zero before putting in 									cache. This is equiv to primFail, and avoids the need to check on 									every send."									primitiveIndex := 0]]						ifFalse: [							"could be an unrun method that got nilled out by the GC"							newMethod = nilObj ifFalse: [								"indicate that this is no compiled method - use primitiveInvokeObjectAsMethod"								primitiveIndex := 248]].					^ true].			index := index + 1.			index = length				ifTrue: [wrapAround						ifTrue: [^ false].					wrapAround := true.					index := SelectorStart]]! !!Interpreter methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 5/22/2011 08:23'!fixedFieldsOf: oop format: fmt length: wordLength"	NOTE: This code supports the backward-compatible extension to 8 bits of instSize.	When we revise the image format, it should become...	^ (classFormat >> 2 bitAnd: 16rFF) - 1"	| class classFormat |	<inline: true>	((fmt > 5) or: [fmt = 2]) ifTrue: [^ 0].  "indexable fields only"	fmt < 2 ifTrue: [^ wordLength].  "fixed fields only (zero or more)"		"fmt = 3, 4, or 5: mixture of fixed and indexable fields, so must look at class format word"	class := self fetchClassOf: oop.	classFormat := self formatOfClass: class.	^ (classFormat >> 11 bitAnd: 16rC0) + (classFormat >> 2 bitAnd: 16r3F) - 1! !!Interpreter methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 5/23/2011 12:11'!markAndTraceInterpreterOopsDiscardingStaleMethods	"Mark and trace all oops in the interpreter's state."	"Assume: All traced variables contain valid oops."	| oop |	self compilerMarkHook.	self markAndTraceDiscardingStaleMethods: specialObjectsOop. "also covers nilObj, trueObj, falseObj, and compact classes"	compilerInitialized		ifTrue: [self markAndTraceDiscardingStaleMethods: receiver.			self markAndTraceDiscardingStaleMethods: method]		ifFalse: [self markAndTraceDiscardingStaleMethods: activeContext].	self markAndTraceDiscardingStaleMethods: messageSelector.	self markAndTraceDiscardingStaleMethods: newMethod.	self markAndTraceDiscardingStaleMethods: methodClass.	self markAndTraceDiscardingStaleMethods: lkupClass.	self markAndTraceDiscardingStaleMethods: receiverClass.	1 to: remapBufferCount do: [:i | 			oop := remapBuffer at: i.			(self isIntegerObject: oop) ifFalse: [self markAndTraceDiscardingStaleMethods: oop]].	"Callback support - trace suspended callback list"	1 to: jmpDepth do:[:i|		oop := suspendedCallbacks at: i.		(self isIntegerObject: oop) ifFalse:[self markAndTraceDiscardingStaleMethods: oop].		oop := suspendedMethods at: i.		(self isIntegerObject: oop) ifFalse:[self markAndTraceDiscardingStaleMethods: oop].	].! !!Interpreter methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 5/26/2011 17:46'!primitiveSnapshotWithoutStaleMethods	"update state of active context"	| activeProc dataSize rcvr setMacType |	<var: #setMacType type: 'void *'>	compilerInitialized		ifTrue: [self compilerPreSnapshot]		ifFalse: [self storeContextRegisters: activeContext].	"update state of active process"	activeProc := self fetchPointer: ActiveProcessIndex ofObject: self schedulerPointer.	self		storePointer: SuspendedContextIndex		ofObject: activeProc		withValue: activeContext.	"compact memory and compute the size of the memory actually in use"	self markAllActiveMethods.	self incrementalGC.	"maximimize space for forwarding table"	self fullGCDiscardingStaleMethods.	self snapshotCleanUp.	dataSize := freeBlock - self startOfMemory. "Assume all objects are below the start of the free block"	self successful		ifTrue: [rcvr := self popStack.			"pop rcvr"			self push: trueObj.			self writeImageFile: dataSize.			"set Mac file type and creator; this is a noop on other platforms"			setMacType := self ioLoadFunction: 'setMacFileTypeAndCreator' From: 'FilePlugin'.			setMacType = 0 ifFalse: [self cCode: '((sqInt (*)(char *, char *, char *))setMacType)(imageName, "STim", "FAST")'].			self pop: 1].	"activeContext was unmarked in #snapshotCleanUp, mark it old "	self beRootIfOld: activeContext.	self successful		ifTrue: [self push: falseObj]		ifFalse: [self push: rcvr].	compilerInitialized		ifTrue: [self compilerPostSnapshot]! !!InterpreterSimulator methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 5/25/2011 10:54'!validate: oop	| header type cc sz fmt nextChunk | 	header := self longAt: oop.	type := header bitAnd: 3.	type = 2 ifFalse: [type = (self rightType: header) ifFalse: [self halt]].	sz := (header bitAnd: self sizeMask) >> 2.	(self isFreeObject: oop)		ifTrue: [ nextChunk := oop + (self sizeOfFree: oop) ]		ifFalse: [  nextChunk := oop + (self sizeBitsOf: oop) ].	nextChunk > endOfMemory		ifTrue: [oop = endOfMemory ifFalse: [self halt]].	(self headerType: nextChunk) = 0 ifTrue: [		(self headerType: (nextChunk + (bytesPerWord * 2))) = 0 ifFalse: [self halt]].	(self headerType: nextChunk) = 1 ifTrue: [		(self headerType: (nextChunk + bytesPerWord)) = 1 ifFalse: [self halt]].	type = 2 ifTrue:		["free block" ^ self].	fmt := (header >> 8) bitAnd: 16rF.	cc := (header >> 12) bitAnd: 31.	cc > 16 ifTrue: [self halt].	"up to 32 are legal, but not used"	type = 0 ifTrue:		["three-word header"		((self longAt: oop - bytesPerWord) bitAnd: 3) = type ifFalse: [self halt].		((self longAt: oop-(bytesPerWord * 2)) bitAnd: 3) = type ifFalse: [self halt].		((self longAt: oop - bytesPerWord) = type) ifTrue: [self halt].	"Class word is 0"		sz = 0 ifFalse: [self halt]].	type = 1 ifTrue:		["two-word header"		((self longAt: oop - bytesPerWord) bitAnd: 3) = type ifFalse: [self halt].		cc > 0 ifTrue: [sz = 1 ifFalse: [self halt]].		sz = 0 ifTrue: [self halt]].	type = 3 ifTrue:		["one-word header"		cc = 0 ifTrue: [self halt]].	"Use format 5 for marked method dictionaries.	fmt = 5 ifTrue: [self halt]."	fmt = 7 ifTrue: [self halt].	fmt >= 12 ifTrue:		["CompiledMethod -- check for integer header"		(self isIntegerObject: (self longAt: oop + bytesPerWord)) ifFalse: [self halt]].! !