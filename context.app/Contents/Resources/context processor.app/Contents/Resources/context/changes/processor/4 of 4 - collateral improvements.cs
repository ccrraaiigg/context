'From Squeak4.2 of 4 February 2011 [latest update: #10966] on 2 November 2013 at 3:36:52 pm'!LargeIntegersPlugin subclass: #LargeIntegersSimulator	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Spoon-Virtual Machine Support'!!InterpreterPlugin methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 5/23/2011 12:49'!msg: s 	<var: #s type: 'char *'>	self cCode: 'fprintf(stderr, "\n%s: %s", moduleName, s)' inSmalltalk: [Transcript "cr; show: self class moduleName , ': ' , s" nextPut: $.; endEntry]! !!BitBltSimulation methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 3/2/2012 13:54'!halftoneAt: idx	"Return a value from the halftone pattern."	^interpreterProxy long32At: halftoneBase + (idx \\ halftoneHeight * 4)! !!BitBltSimulation methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 3/2/2012 22:48'!primitiveDisplayString	| kernDelta xTable glyphMap stopIndex startIndex sourceString bbObj maxGlyph ascii glyphIndex sourcePtr left quickBlt |	<export: true>	<var: #sourcePtr type: 'char *'>	interpreterProxy methodArgumentCount = 6 		ifFalse:[^interpreterProxy primitiveFail].	kernDelta := interpreterProxy stackIntegerValue: 0.	xTable := interpreterProxy stackObjectValue: 1.	glyphMap := interpreterProxy stackObjectValue: 2.	((interpreterProxy fetchClassOf: xTable) = interpreterProxy classArray and:[		(interpreterProxy fetchClassOf: glyphMap) = interpreterProxy classArray])			ifFalse:[^interpreterProxy primitiveFail].	(interpreterProxy slotSizeOf: glyphMap) = 256 ifFalse:[^interpreterProxy primitiveFail].	interpreterProxy failed ifTrue:[^nil].	maxGlyph := (interpreterProxy slotSizeOf: xTable) - 2.	stopIndex := interpreterProxy stackIntegerValue: 3.	startIndex := interpreterProxy stackIntegerValue: 4.	sourceString := interpreterProxy stackObjectValue: 5.	(interpreterProxy isBytes: sourceString) ifFalse:[^interpreterProxy primitiveFail].	(startIndex > 0 and:[stopIndex > 0 and:[		stopIndex <= (interpreterProxy byteSizeOf: sourceString)]])			ifFalse:[^interpreterProxy primitiveFail].	bbObj := interpreterProxy stackObjectValue: 6.	(self loadBitBltFrom: bbObj) ifFalse:[^interpreterProxy primitiveFail].	(combinationRule = 30 or:[combinationRule = 31]) "needs extra source alpha"		ifTrue:[^interpreterProxy primitiveFail].	"See if we can go directly into copyLoopPixMap (usually we can)"	quickBlt := destBits ~= 0 "no OS surfaces please"				and:[sourceBits ~= 0 "and again"				and:[noSource = false "needs a source"				and:[sourceForm ~= destForm "no blits onto self"				and:[(cmFlags ~= 0 						or:[sourceMSB ~= destMSB 						or:[sourceDepth ~= destDepth]]) "no point using slower version"				]]]].	left := destX.	sourcePtr := interpreterProxy firstIndexableField: sourceString.	startIndex to: stopIndex do:[:charIndex|		ascii := interpreterProxy byteAtPointer: sourcePtr + charIndex - 1.		glyphIndex := interpreterProxy fetchInteger: ascii ofObject: glyphMap.		(glyphIndex < 0 or:[glyphIndex > maxGlyph]) 			ifTrue:[^interpreterProxy primitiveFail].		sourceX := interpreterProxy fetchInteger: glyphIndex ofObject: xTable.		width := (interpreterProxy fetchInteger: glyphIndex+1 ofObject: xTable) - sourceX.		interpreterProxy failed ifTrue:[^nil].		self clipRange.	"Must clip here"		(bbW > 0 and:[bbH > 0]) ifTrue: [			quickBlt ifTrue:[				self destMaskAndPointerInit.				self copyLoopPixMap.				"both, hDir and vDir are known to be > 0"				affectedL := dx.				affectedR := dx + bbW.				affectedT := dy.				affectedB := dy + bbH.			] ifFalse:[self copyBits]].		interpreterProxy failed ifTrue:[^nil].		destX := destX + width + kernDelta.	 ].	affectedL := left.	self showDisplayBits.	interpreterProxy pop: 6. "pop args, return rcvr"! !!BitBltSimulator methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 2/26/2012 21:42'!dstLongAt: dstIndex	interpreterProxy isInterpreterProxy		ifTrue:[^dstIndex long32At: 0].	((dstIndex anyMask: 3) or:[dstIndex + 4 < destBits or:[		dstIndex > (destBits + (destPitch * destHeight))]])			ifTrue:[self error:'Out of bounds'].	^interpreterProxy long32At: dstIndex! !!BitBltSimulator methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 2/26/2012 21:43'!dstLongAt: dstIndex put: value	interpreterProxy isInterpreterProxy		ifTrue:[^dstIndex long32At: 0 put: value].	((dstIndex anyMask: 3) or:[dstIndex < destBits or:[		dstIndex >= (destBits + (destPitch * destHeight))]])			ifTrue:[self error:'Out of bounds'].	^interpreterProxy long32At: dstIndex put: value! !!BitBltSimulator methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 2/26/2012 21:42'!srcLongAt: srcIndex	interpreterProxy isInterpreterProxy		ifTrue:[^srcIndex long32At: 0].	((srcIndex anyMask: 3) or:[srcIndex + 4 < sourceBits or:[		srcIndex > (sourceBits + (sourcePitch * sourceHeight))]])			ifTrue:[self error:'Out of bounds'].	^interpreterProxy long32At: srcIndex! !!BitBltSimulator methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 3/2/2012 22:48'!tableLookup: table at: index	^ interpreterProxy long32At: (table + (index * 4))! !!LargeIntegersPlugin class methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 5/26/2011 14:35'!simulatorClass	^LargeIntegersSimulator! !!LargeIntegersSimulator methodsFor: 'oop functions' stamp: 'crl 3/2/2012 12:57'!digitDivLarge: firstInteger with: secondInteger negative: neg 	"Does not normalize."	"Division by zero has to be checked in caller."	| firstLen secondLen resultClass l d div rem quo result |	firstLen _ self byteSizeOfBytes: firstInteger.	secondLen _ self byteSizeOfBytes: secondInteger.	neg		ifTrue: [resultClass _ interpreterProxy classLargeNegativeInteger]		ifFalse: [resultClass _ interpreterProxy classLargePositiveInteger].	l _ firstLen - secondLen + 1.	l <= 0		ifTrue: 			[self remapOop: firstInteger in: [result _ interpreterProxy instantiateClass: interpreterProxy classArray indexableSize: 2].			interpreterProxy				stObject: result at: 1 put: (0 asOop: SmallInteger);				stObject: result at: 2 put: firstInteger.			^ result].	"set rem and div to copies of firstInteger and secondInteger, respectively. 	  However,  	 to facilitate use of Knuth's algorithm, multiply rem and div by 2 (that 	 is, shift)   	 until the high byte of div is >=128"	d _ 8 - (self cHighBit: (self unsafeByteOf: secondInteger at: secondLen)).	self remapOop: firstInteger		in: 			[div _ self bytes: secondInteger Lshift: d.			div _ self bytesOrInt: div growTo: (self digitLength: div)							+ 1].	self remapOop: div		in: 			[rem _ self bytes: firstInteger Lshift: d.			(self digitLength: rem)				= firstLen ifTrue: [rem _ self bytesOrInt: rem growTo: firstLen + 1]].	self remapOop: #(div rem ) in: [quo _ interpreterProxy instantiateClass: resultClass indexableSize: l].	self		cCoreDigitDivDiv: (interpreterProxy firstIndexableField: div)		len: (self digitLength: div)		rem: (interpreterProxy firstIndexableField: rem)		len: (self digitLength: rem)		quo: (interpreterProxy firstIndexableField: quo)		len: (self digitLength: quo).	self remapOop: #(quo ) in: [rem _ self					bytes: rem					Rshift: d					bytes: 0					lookfirst: (self digitLength: div)							- 1].	"^ Array with: quo with: rem"	self remapOop: #(quo rem ) in: [result _ interpreterProxy instantiateClass: interpreterProxy classArray indexableSize: 2].	interpreterProxy		stObject: result at: 1 put: quo;		stObject: result at: 2 put: rem.	^ result! !!LargeIntegersSimulator methodsFor: 'Integer primitives' stamp: 'crl 2/12/2006 01:17'!primDigitAdd	| sum |	sum _ self primDigitAdd: (interpreterProxy stackValue: 0).	interpreterProxy		pop: 2;		push: sum! !!LargeIntegersSimulator methodsFor: 'Integer primitives' stamp: 'crl 2/12/2006 01:17'!primDigitBitAnd	| result |	result _ self primDigitBitAnd: (interpreterProxy stackValue: 0).	interpreterProxy		pop: 2;		push: result! !!LargeIntegersSimulator methodsFor: 'Integer primitives' stamp: 'crl 2/12/2006 01:17'!primDigitBitShiftMagnitude	| result |	result _ self primDigitBitShiftMagnitude: (interpreterProxy stackIntegerValue: 0).	interpreterProxy		pop: 2;		push: result! !!LargeIntegersSimulator methodsFor: 'Integer primitives' stamp: 'crl 2/12/2006 01:18'!primDigitCompare	| result |	result _ self primDigitCompare: (interpreterProxy stackValue: 0).	interpreterProxy		pop: 2;		push: result! !!LargeIntegersSimulator methodsFor: 'Integer primitives' stamp: 'crl 2/12/2006 01:18'!primDigitDivNegative	| result |	result _ (		self			primDigitDiv: (interpreterProxy stackValue: 1)			negative: (interpreterProxy stackValue: 0)).	interpreterProxy		pop: 3;		push: result! !!LargeIntegersSimulator methodsFor: 'Integer primitives' stamp: 'crl 2/12/2006 11:58'!primDigitMultiplyNegative	| result |	result _ (		self			primDigitMultiply: (interpreterProxy stackValue: 1)			negative: (interpreterProxy stackValue: 0)).	interpreterProxy		pop: 3;		push: result! !!LargeIntegersSimulator methodsFor: 'Integer primitives' stamp: 'crl 2/12/2006 01:18'!primDigitSubtract	| difference |	difference _ self primDigitSubtract: (interpreterProxy stackValue: 0).	interpreterProxy		pop: 2;		push: difference! !!LargeIntegersSimulator methodsFor: 'Integer primitives' stamp: 'crl 2/12/2006 11:58'!primNormalizeNegative	| result |	result _ super primNormalizeNegative.	interpreterProxy		pop: 1;		push: result! !!LargeIntegersSimulator methodsFor: 'Integer primitives' stamp: 'crl 2/12/2006 11:58'!primNormalizePositive	| result |	result _ super primNormalizePositive.	interpreterProxy		pop: 1;		push: result! !!ObjectMemory methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 5/25/2011 15:47'!classArray	^self splObj: ClassArray! !!Interpreter methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 5/26/2011 18:03'!printNameOfClass: classOop count: cnt	"Details: The count argument is used to avoid a possible infinite recursion if classOop is a corrupted object."	cnt <= 0 ifTrue: [ ^ self print: 'bad class' ].	(self sizeBitsOf: classOop) = (7 * self bytesPerWord)	"(Metaclass instSize+1 * 4)"		ifTrue: [self printNameOfClass: (self fetchPointer: 5 "thisClass" ofObject: classOop) 					count: cnt - 1.				self print: ' class']	ifFalse: [		self printStringOf: (self fetchPointer: 0 ofObject: (self fetchPointer: 6 "name" ofObject: classOop))]! !!Interpreter methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 5/23/2011 12:27'!rawLengthOf: oop	"Return the number of indexable bytes or words in the given object. Assume the argument is not an integer. For a CompiledMethod, the size of the method header (in bytes) should be subtracted from the result."	| header |	header := self baseHeader: oop.	^ self rawLengthOf: oop baseHeader: header format: ((header >> 8) bitAnd: 16rF)! !!Interpreter methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 5/23/2011 12:28'!rawLengthOf: oop baseHeader: hdr format: fmt	"Return the number of indexable bytes or words in the given object. Assume the given oop is not an integer."	| sz |	(hdr bitAnd: TypeMask) = HeaderTypeSizeAndClass		ifTrue: [ sz := (self sizeHeader: oop) bitAnd: self allButTypeMask ]		ifFalse: [ sz := hdr bitAnd: self sizeMask ].	^sz! !!Interpreter methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 5/23/2011 12:14'!okayOop: signedOop	"Verify that the given oop is legitimate. Check address, header, and size but not class."	| sz type fmt unusedBit oop |	<var: #oop type: 'usqInt'>	oop := self cCoerce: signedOop to: 'usqInt'.	"address and size checks"	(self isIntegerObject: oop) ifTrue: [ ^true ].	((oop > 0) & (oop < endOfMemory))		ifFalse: [ self error: 'oop is not a valid address' ].	((oop \\ self bytesPerWord) = 0)		ifFalse: [ self error: 'oop is not a word-aligned address' ].	sz := self sizeBitsOf: oop.	(oop + sz) < endOfMemory		ifFalse: [ self error: 'oop size would make it extend beyond the end of memory' ].	"header type checks"	type := self headerType: oop.	type = HeaderTypeFree		ifTrue:  [ self error: 'oop is a free chunk, not an object' ].	type = HeaderTypeShort ifTrue: [		(((self baseHeader: oop) >> 12) bitAnd: 16r1F) = 0			ifTrue:  [ self error: 'cannot have zero compact class field in a short header' ].	].	type = HeaderTypeClass ifTrue: [		((oop >= self bytesPerWord) and: [(self headerType: oop - self bytesPerWord) = type])			ifFalse: [ self error: 'class header word has wrong type' ].	].	type = HeaderTypeSizeAndClass ifTrue: [		((oop >= (self bytesPerWord * 2)) and:		 [(self headerType: oop - (self bytesPerWord * 2)) = type and:		 [(self headerType: oop - self bytesPerWord) = type]])			ifFalse: [ self error: 'class header word has wrong type' ].	].	"format check"	fmt := self formatOf: oop.	(fmt = 7)		ifTrue:  [ self error: 'oop has an unknown format type' ].	"mark and root bit checks"	unusedBit := 16r20000000.	self bytesPerWord = 8		ifTrue:			[unusedBit := unusedBit << 16.			 unusedBit := unusedBit << 16].	((self longAt: oop) bitAnd: unusedBit) = 0		ifFalse: [ self error: 'unused header bit 30 is set; should be zero' ]."xxx	((self longAt: oop) bitAnd: MarkBit) = 0		ifFalse: [ self error: 'mark bit should not be set except during GC' ].xxx"	(((self longAt: oop) bitAnd: self rootBit) = 1 and:	 [oop >= youngStart])		ifTrue: [ self error: 'root bit is set in a young object' ].	^true! !!Interpreter methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'ikp (auto pragmas dtl 2010-09-26) 3/26/2005 21:06'!oopHasOkayClass: signedOop	"Attempt to verify that the given oop has a reasonable behavior. The class must be a valid, non-integer oop and must not be nilObj. It must be a pointers object with three or more fields. Finally, the instance specification field of the behavior must match that of the instance."	| oop oopClass formatMask behaviorFormatBits oopFormatBits |	<var: #oop type: 'usqInt'>	<var: #oopClass type: 'usqInt'>	oop := self cCoerce: signedOop to: 'usqInt'.	self okayOop: oop.	oopClass := self cCoerce: (self fetchClassOf: oop) to: 'usqInt'.	(self isIntegerObject: oopClass)		ifTrue: [ self error: 'a SmallInteger is not a valid class or behavior' ].	self okayOop: oopClass.	((self isPointers: oopClass) and: [(self lengthOf: oopClass) >= 3])		ifFalse: [ self error: 'a class (behavior) must be a pointers object of size >= 3' ].	(self isBytes: oop)		ifTrue: [ formatMask := 16rC00 ]  "ignore extra bytes size bits"		ifFalse: [ formatMask := 16rF00 ].	behaviorFormatBits := (self formatOfClass: oopClass) bitAnd: formatMask.	oopFormatBits := (self baseHeader: oop) bitAnd: formatMask.	behaviorFormatBits = oopFormatBits		ifFalse: [ self error: 'object and its class (behavior) formats differ' ].	^true! !!Interpreter methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 5/22/2011 07:48'!classNameOf: aClass Is: className 	"Check if aClass's name is className"	| srcName name length |	<var: #className type: 'char *'>	<var: #srcName type: 'char *'>	(self lengthOf: aClass) <= 6 ifTrue: [^ false].	"Not a class but might be behavior"	name := self fetchPointer: 0 ofObject: (self fetchPointer: 6 ofObject: aClass).	(self isBytes: name) ifFalse: [^ false].	length := self stSizeOf: name.	srcName := self cCoerce: (self arrayValueOf: name) to: 'char *'.	0 to: length - 1 do: [:i | (srcName at: i) = (className at: i) ifFalse: [^ false]].	"Check if className really ends at this point"	^ (className at: length) = 0! !!Interpreter class methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 8/17/2012 18:14'!getSystemAttribute: attributeID 	"Optional. Answer the string for the system attribute with the given 	integer ID. Answer nil if the given attribute is not defined on this 	platform. On platforms that support invoking programs from command 	lines (e.g., Unix), this mechanism can be used to pass command line 	arguments to programs written in Squeak.	By convention, the first command line argument that is not a VM	configuration option is considered a 'document' to be filed in. Such a	document can add methods and classes, can contain a serialized object,	can include code to be executed, or any combination of these.	Currently defined attributes include: 	-1000...-1 - command line arguments that specify VM options 	0 - the full path name for currently executing VM 	(or, on some platforms, just the path name of the VM's directory) 	1 - full path name of this image 	2 - a Squeak document to open, if any 	3...1000 - command line arguments for Squeak programs 	1001 - this platform's operating system 	1002 - operating system version 	1003 - this platform's processor type	1004 - vm version"	<primitive: 149>	^ nil! !!Interpreter class methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 8/24/2012 10:15'!imagePath	"Answer the full path name for the current image."	| path primPath |		path := (String new: 32) writableStream.	primPath := self primImageName.		path nextPutAll: 'file://'.	(primPath first = $/) ifFalse: [path nextPut: $/].	path nextPutAll: (self primImageName copyReplaceAll: '\' with: '/').		^path contents! !!Interpreter class methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 8/17/2012 18:14'!platformName	"Return the name of the platform we're running on"	^self getSystemAttribute: 1001! !!Interpreter class methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 8/24/2012 10:25'!primAppPath	<primitive: 142>	^ ''! !!Interpreter class methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 8/17/2012 09:52'!primImageName	"Answer the full path name for the current image."	"SmalltalkImage current imageName"	<primitive: 121>	self primitiveFailed! !!Interpreter class methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 8/17/2012 09:53'!primVmPath	"Answer the path for the directory containing the Smalltalk virtual machine. Return the 	empty string if this primitive is not implemented."	"SmalltalkImage current vmPath"	<primitive: 142>	^ ''! !!Interpreter class methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 8/17/2012 18:29'!resumeMemoryNamed: memoryName usingProcessorNamed: processorName	<primitive: 'forkMemoryUsingProcessor' module: 'Flow'>	self primitiveFailed! !!InterpreterSimulator methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 4/15/2007 11:29'!pop: nItems	"Note: May be called by translated primitive code."	(thisContext sender receiver class == Flow) ifTrue: [		Transcript			nextPut: $.;			endEntry].	super pop: nItems! !!InterpreterSimulator methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 4/15/2007 10:40'!nameOfClass: classOop	^(		((self sizeBitsOf: classOop) = (Metaclass instSize + 1 * 4))			ifTrue: [				(					self nameOfClass: (						"thisClass"						self fetchPointer: 5 ofObject: classOop)				)					, ' class']			ifFalse: [				[					| name |					name := self fetchPointer: 6 ofObject: classOop.					self stringOf: (						((self fetchClassOf: name) = (self fetchClassOf: (self fetchPointer: 20 ofObject: specialObjectsOop)))							ifTrue: [								"The name is a Symbol."								name]							ifFalse: [								"The name is a ReadOnlyVariableBinding."								self fetchPointer: 0 ofObject: name]						)				]					on: Error					do: [:exception |						(							self nameOfClass: (								"thisClass"								self fetchPointer: 5 ofObject: classOop)						)							, ' class']]	)		asSymbol! !!InterpreterSimulator methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 5/25/2011 10:53'!primitiveGetAttribute	"Fetch the system attribute with the given integer ID. The result is a string, which will be empty if the attribute is not defined."	| attr s attribute |	attr := self stackIntegerValue: 0.	self successful ifTrue: [		attribute := SmalltalkImage current getSystemAttribute: attr.		attribute ifNil: [ ^self primitiveFail ].		s := self instantiateClass: (self splObj: ClassString) indexableSize: attribute size.		1 to: attribute size do: [ :i |			self storeByte: i-1 ofObject: s withValue: (attribute at: i) asciiValue].		self pop: 2.  "rcvr, attr"		self push: s].! !!InterpreterSimulator methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 3/1/2012 01:37'!classNameOf: aClass Is: className	"Check if aClass' name is className"	| name |	(self lengthOf: aClass) <= 6 ifTrue:[^false]. "Not a class but maybe behavior" 	name := self fetchPointer: 6 ofObject: aClass.	(self isBytes: name) ifFalse:[^false].	^ className = (self stringOf: name).! !!InterpreterSimulator methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 5/25/2011 15:56'!successful	^primFailCode == 0! !!InterpreterSimulator class methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 4/15/2007 00:46'!openOn: pathname	^self new openOn: pathname! !!InterpreterSimulator class methodsFor: '*System-Spoon-Virtual Machine Support' stamp: 'crl 4/15/2007 00:46'!simulate: snapshotPathString	"Simulate the snapshot corresponding to snapshotPathString."	^(self openOn: snapshotPathString) test! !